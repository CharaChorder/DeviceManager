import {
  decorateStory,
  render,
  renderToCanvas
} from "./chunk-RVB75JOG.js";
import "./chunk-X7HCJ7ZS.js";
import "./chunk-CTY5WESM.js";
import "./chunk-AHP5BEQT.js";
import "./chunk-TTOOQL5P.js";
import {
  SNIPPET_RENDERED,
  SourceType,
  enhanceArgTypes
} from "./chunk-Z4TEKGYV.js";
import "./chunk-FPWI56YW.js";
import "./chunk-YYBF3UNG.js";
import "./chunk-4Y4WCA2M.js";
import "./chunk-O2RBE7SN.js";
import "./chunk-VAXZSSBI.js";
import "./chunk-6LB25D5D.js";
import "./chunk-WUKUIZIT.js";
import "./chunk-7AXDYAXS.js";
import "./chunk-QD62T54I.js";
import "./chunk-OLRBVLII.js";
import "./chunk-6BG24PK2.js";
import "./chunk-63K4YQFB.js";
import "./chunk-KFNG2BBP.js";
import "./chunk-4BX7ITSR.js";
import "./chunk-3HYIM526.js";
import "./chunk-OFZK2TAA.js";
import "./chunk-HLF5CGUE.js";
import "./chunk-3UIITD3Q.js";
import "./chunk-GN66SBWY.js";
import "./chunk-UQJ2EEVJ.js";
import "./chunk-Z3HAMAVX.js";
import "./chunk-OQGF6EPH.js";
import "./chunk-JUFWCB3J.js";
import "./chunk-PMQZHR4Z.js";
import "./chunk-Z4RIRXNM.js";
import "./chunk-J6CEENEN.js";
import {
  require_preview_api
} from "./chunk-CQBMCNM3.js";
import {
  require_client_logger
} from "./chunk-3GLQDQAQ.js";
import {
  __toESM
} from "./chunk-USJHI7ER.js";

// node_modules/@storybook/svelte/dist/config.mjs
var import_client_logger = __toESM(require_client_logger(), 1);
var import_preview_api = __toESM(require_preview_api(), 1);
function hasKeyword(keyword, keywords) {
  return keywords ? keywords.find((k) => k.name === keyword) != null : false;
}
var extractArgTypes = (component) => {
  try {
    let docgen = component.__docgen;
    if (docgen)
      return createArgTypes(docgen);
  } catch (err) {
    import_client_logger.logger.log(`Error extracting argTypes: ${err}`);
  }
  return {};
};
var createArgTypes = (docgen) => {
  let results = {};
  return docgen.data && docgen.data.forEach((item) => {
    var _a, _b;
    results[item.name] = { control: parseTypeToControl(item.type), name: item.name, description: item.description || void 0, type: { required: hasKeyword("required", item.keywords || []), name: (_a = item.type) == null ? void 0 : _a.text }, table: { type: { summary: (_b = item.type) == null ? void 0 : _b.text }, defaultValue: { summary: item.defaultValue }, category: "properties" } };
  }), docgen.events && docgen.events.forEach((item) => {
    results[`event_${item.name}`] = { name: item.name, action: item.name, control: false, ...item.description ? { description: item.description } : {}, table: { category: "events" } };
  }), docgen.slots && docgen.slots.forEach((item) => {
    var _a;
    results[`slot_${item.name}`] = { name: item.name, control: false, description: [item.description, (_a = item.params) == null ? void 0 : _a.map((p) => `\`${p.name}\``).join(" ")].filter((p) => p).join(`

`), table: { category: "slots" } };
  }), results;
};
var parseTypeToControl = (type) => {
  if (!type)
    return null;
  if (type.kind === "type")
    switch (type.type) {
      case "string":
        return { type: "text" };
      case "enum":
        return { type: "radio" };
      case "any":
        return { type: "object" };
      default:
        return { type: type.type };
    }
  else if (type.kind === "union" && Array.isArray(type.type) && !type.type.find((t) => t.type !== "string"))
    return { type: "radio", options: type.type.filter((t) => t.kind === "const").map((t) => t.value) };
  return null;
};
function extractComponentDescription(component) {
  if (!component)
    return "";
  let { __docgen = {} } = component;
  return __docgen.description;
}
var skipSourceRender = (context) => {
  var _a;
  let sourceParams = (_a = context == null ? void 0 : context.parameters.docs) == null ? void 0 : _a.source, isArgsStory = context == null ? void 0 : context.parameters.__isArgsStory;
  return (sourceParams == null ? void 0 : sourceParams.type) === SourceType.DYNAMIC ? false : !isArgsStory || (sourceParams == null ? void 0 : sourceParams.code) || (sourceParams == null ? void 0 : sourceParams.type) === SourceType.CODE;
};
function toSvelteProperty(key, value, argTypes) {
  return value == null || argTypes[key] && argTypes[key].defaultValue === value ? null : value === true ? key : typeof value == "string" ? `${key}=${JSON.stringify(value)}` : `${key}={${JSON.stringify(value)}}`;
}
function getComponentName(component) {
  if (component == null)
    return null;
  let { __docgen = {} } = component, { name } = __docgen;
  return name ? (name.endsWith(".svelte") && (name = name.substring(0, name.length - 7)), name) : component.name;
}
function generateSvelteSource(component, args, argTypes, slotProperty) {
  let name = getComponentName(component);
  if (!name)
    return null;
  let props = Object.entries(args).filter(([k]) => k !== slotProperty).map(([k, v]) => toSvelteProperty(k, v, argTypes)).filter((p) => p).join(" "), slotValue = slotProperty ? args[slotProperty] : null;
  return slotValue ? `<${name} ${props}>
    ${slotValue}
</${name}>` : `<${name} ${props}/>`;
}
function getWrapperProperties(component) {
  var _a;
  let { __docgen } = component;
  return __docgen ? __docgen.keywords.find((kw) => kw.name === "wrapper") ? { wrapper: true, slotProperty: (_a = __docgen.data.find((prop) => prop.keywords.find((kw) => kw.name === "slot"))) == null ? void 0 : _a.name } : { wrapper: false } : { wrapper: false };
}
var sourceDecorator = (storyFn, context) => {
  let channel = import_preview_api.addons.getChannel(), skip = skipSourceRender(context), story = storyFn(), source;
  if ((0, import_preview_api.useEffect)(() => {
    if (!skip && source) {
      let { id, unmappedArgs } = context;
      channel.emit(SNIPPET_RENDERED, { id, args: unmappedArgs, source });
    }
  }), skip)
    return story;
  let { parameters: parameters3 = {}, args = {}, component: ctxtComponent } = context || {}, { Component: component = {} } = story, { wrapper, slotProperty } = getWrapperProperties(component);
  wrapper && (parameters3.component && (0, import_client_logger.deprecate)("parameters.component is deprecated. Using context.component instead."), component = ctxtComponent);
  let generated = generateSvelteSource(component, args, context == null ? void 0 : context.argTypes, slotProperty);
  return generated && (source = generated), story;
};
var parameters = { docs: { story: { inline: true }, extractArgTypes, extractComponentDescription } };
var decorators = [sourceDecorator];
var argTypesEnhancers = [enhanceArgTypes];
var parameters2 = { renderer: "svelte", ...parameters };
export {
  decorateStory as applyDecorators,
  argTypesEnhancers,
  decorators,
  parameters2 as parameters,
  render,
  renderToCanvas
};
//# sourceMappingURL=@storybook_svelte_preview.js.map
