{
  "version": 3,
  "sources": ["../../typesafe-i18n/runtime/esm/parser/src/basic.mjs", "../../typesafe-i18n/runtime/esm/runtime/src/core.mjs", "../../typesafe-i18n/runtime/esm/runtime/src/util.string.mjs", "../../typesafe-i18n/runtime/esm/runtime/src/util.object.mjs", "../../typesafe-i18n/runtime/esm/runtime/src/util.instance.mjs"],
  "sourcesContent": ["// --------------------------------------------------------------------------------------------------------------------\n// types --------------------------------------------------------------------------------------------------------------\n// --------------------------------------------------------------------------------------------------------------------\n// --------------------------------------------------------------------------------------------------------------------\n// implementation -----------------------------------------------------------------------------------------------------\n// --------------------------------------------------------------------------------------------------------------------\n// eslint-disable-next-line prettier/prettier\nconst removeEmptyValues = (object) => Object.fromEntries(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nObject.entries(object)\n    .map(([key, value]) => key !== 'i' && value && value != '0' && [key, value])\n    .filter(Boolean));\n// --------------------------------------------------------------------------------------------------------------------\nconst trimAllValues = (part) => Object.fromEntries(Object.keys(part).map((key) => {\n    const val = part[key];\n    return [\n        key,\n        Array.isArray(val) ? val.map((v) => v === null || v === void 0 ? void 0 : v.trim()) : val === !!val ? val : val === null || val === void 0 ? void 0 : val.trim(),\n    ];\n}));\n// --------------------------------------------------------------------------------------------------------------------\nconst parseArgumentPart = (text) => {\n    const [keyPart = '', ...formatterKeys] = text.split('|');\n    const [keyWithoutType = '', type] = keyPart.split(':');\n    const [key, isOptional] = keyWithoutType.split('?');\n    return { k: key, i: type, n: isOptional === '', f: formatterKeys };\n};\n// --------------------------------------------------------------------------------------------------------------------\nexport const isBasicPluralPart = (part) => !!(part.o || part.r);\nconst parsePluralPart = (content, lastAccessor) => {\n    let [key, values] = content.split(':');\n    if (!values) {\n        values = key;\n        key = lastAccessor;\n    }\n    const entries = values.split('|');\n    const [zero, one, two, few, many, rest] = entries;\n    const nrOfEntries = entries.filter((entry) => entry !== undefined).length;\n    if (nrOfEntries === 1) {\n        return { k: key, r: zero };\n    }\n    if (nrOfEntries === 2) {\n        return { k: key, o: zero, r: one };\n    }\n    if (nrOfEntries === 3) {\n        return { k: key, z: zero, o: one, r: two };\n    }\n    return { k: key, z: zero, o: one, t: two, f: few, m: many, r: rest };\n};\n// --------------------------------------------------------------------------------------------------------------------\nexport const REGEX_SWITCH_CASE = /^\\{.*\\}$/;\nexport const parseCases = (text) => Object.fromEntries(removeOuterBrackets(text)\n    .split(',')\n    .map((part) => part.split(':'))\n    .reduce((accumulator, entry) => {\n    if (entry.length === 2) {\n        return [...accumulator, entry.map((entry) => entry.trim())];\n    }\n    // if we have a single part, this means that a comma `,` was present in the string and we need to combine the strings again\n    ;\n    accumulator[accumulator.length - 1][1] += ',' + entry[0];\n    return accumulator;\n}, []));\n// --------------------------------------------------------------------------------------------------------------------\nconst REGEX_BRACKETS_SPLIT = /(\\{(?:[^{}]+|\\{(?:[^{}]+)*\\})*\\})/g;\nexport const removeOuterBrackets = (text) => text.substring(1, text.length - 1);\nexport const parseRawText = (rawText, optimize = true, firstKey = '', lastKey = '') => rawText\n    .split(REGEX_BRACKETS_SPLIT)\n    .map((part) => {\n    if (!part.match(REGEX_BRACKETS_SPLIT)) {\n        return part;\n    }\n    const content = removeOuterBrackets(part);\n    if (content.startsWith('{')) {\n        return parsePluralPart(removeOuterBrackets(content), lastKey);\n    }\n    const parsedPart = parseArgumentPart(content);\n    lastKey = parsedPart.k || lastKey;\n    !firstKey && (firstKey = lastKey);\n    return parsedPart;\n})\n    .map((part) => {\n    if (typeof part === 'string')\n        return part;\n    if (!part.k)\n        part.k = firstKey || '0';\n    const trimmed = trimAllValues(part);\n    return optimize ? removeEmptyValues(trimmed) : trimmed;\n});\n", "import { REGEX_SWITCH_CASE, isBasicPluralPart, parseCases, } from '../../parser/src/basic.mjs';\n// --------------------------------------------------------------------------------------------------------------------\n// implementation -----------------------------------------------------------------------------------------------------\n// --------------------------------------------------------------------------------------------------------------------\nconst applyFormatters = (formatters, formatterKeys, initialValue) => formatterKeys.reduce((value, formatterKey) => {\n    var _a, _b;\n    return (_b = (formatterKey.match(REGEX_SWITCH_CASE)\n        ? ((cases) => { var _a; return (_a = cases[value]) !== null && _a !== void 0 ? _a : cases['*']; })(parseCases(formatterKey))\n        : (_a = formatters[formatterKey]) === null || _a === void 0 ? void 0 : _a.call(formatters, value))) !== null && _b !== void 0 ? _b : value;\n}, initialValue);\nconst getPlural = (pluralRules, { z, o, t, f, m, r }, value) => {\n    switch (z && value == 0 ? 'zero' : pluralRules.select(value)) {\n        case 'zero':\n            return z;\n        case 'one':\n            return o;\n        case 'two':\n            return t;\n        case 'few':\n            return f !== null && f !== void 0 ? f : r;\n        case 'many':\n            return m !== null && m !== void 0 ? m : r;\n        default:\n            return r;\n    }\n};\nconst REGEX_PLURAL_VALUE_INJECTION = /\\?\\?/g;\nconst applyArguments = (textParts, pluralRules, formatters, args) => textParts\n    .map((part) => {\n    if (typeof part === 'string') {\n        return part;\n    }\n    const { k: key = '0', f: formatterKeys = [] } = part;\n    const value = args[key];\n    if (isBasicPluralPart(part)) {\n        return ((typeof value === 'boolean' ? (value ? part.o : part.r) : getPlural(pluralRules, part, value)) || '').replace(REGEX_PLURAL_VALUE_INJECTION, value);\n    }\n    const formattedValue = formatterKeys.length ? applyFormatters(formatters, formatterKeys, value) : value;\n    return ('' + (formattedValue !== null && formattedValue !== void 0 ? formattedValue : '')).trim();\n})\n    .join('');\nexport const translate = (textParts, pluralRules, formatters, args) => {\n    const firstArg = args[0];\n    const isObject = firstArg && typeof firstArg === 'object' && firstArg.constructor === Object;\n    const transformedArgs = (args.length === 1 && isObject ? firstArg : args);\n    return applyArguments(textParts, pluralRules, formatters, transformedArgs);\n};\n// type TransformArgsArray<A extends Array<Record<string, unknown>>> = keyof A[0] extends `${number}`\n// \t? ToIndexBasedArgs<A>\n// \t: A\n// type ToIndexBasedArgs<A extends Array<Record<string, unknown>>, B extends keyof A[0] = keyof A[0]> = GetTypesFromRecord<\n// \tA[0],\n// \tSort<ToNumberArray<ToTuple<B>>>\n// >\n// type GetTypesFromRecordAsArray<A extends Record<string, unknown>, B extends unknown[]> = B extends [infer Item, ...infer Rest]\n// \t? [A[Item], ...XX<A, Rest>]\n// \t: []\n// type UnionToParm<U> = U extends any ? (k: U) => void : never\n// type UnionToSect<U> = UnionToParm<U> extends (k: infer I) => void ? I : never\n// type ExtractParm<F> = F extends { (a: infer A): void } ? A : never\n// type SpliceOne<Union> = Exclude<Union, ExtractOne<Union>>\n// type ExtractOne<Union> = ExtractParm<UnionToSect<UnionToParm<Union>>>\n// type ToTuple<Union> = ToTupleRec<Union, []>\n// type ToTupleRec<Union, Rslt extends any[]> = SpliceOne<Union> extends never\n// \t? [ExtractOne<Union>, ...Rslt]\n// \t: ToTupleRec<SpliceOne<Union>, [ExtractOne<Union>, ...Rslt]>\n// type GenList<N, A extends any[] = []> = N extends A['length'] ? A : GenList<N, [0, ...A]>\n// // Add lists of size: [1, 2] -> [[1, [_]], [2, [_, _]]]\n// type Expand<T extends any[]> = T extends [infer Head, ...infer Rest] ? [[Head, GenList<Head>], ...Expand<Rest>] : []\n// // Drop one from each list, remove whole pair for empty: [[1, [_]], [0, []], [2, [_, _]]] -> [[1, []], [2, [_]]]\n// type DropAndFilter<T> = T extends [infer First, ...infer Rest]\n// \t? First extends [any, []]\n// \t\t? DropAndFilter<Rest>\n// \t\t: First extends [infer N, [any, ...infer NREST]]\n// \t\t? [[N, NREST], ...DropAndFilter<Rest>]\n// \t\t: []\n// \t: []\n// // [[1, []], [2, [_]]] -> [1]\n// type FindEmpty<T> = T extends [infer First, ...infer Rest]\n// \t? First extends [infer N, []]\n// \t\t? [N, ...FindEmpty<Rest>]\n// \t\t: FindEmpty<Rest>\n// \t: []\n// // Sort expanded\n// type Condense<T extends [number, any[]][], Result extends number[] = []> = T extends []\n// \t? Result\n// \t: Condense<DropAndFilter<T>, [...Result, ...FindEmpty<T>]>\n// type Reverse<A extends any[]> = A extends [infer H, ...infer T] ? [...Reverse<T>, H] : []\n// type Sort<T extends any[], R = false> = R extends true ? Reverse<Condense<Expand<T>>> : Condense<Expand<T>>\n// type ToNumberArray<T extends unknown[]> = T extends [infer Item, ...infer Rest]\n// \t? [ToNumber<Item>, ...ToNumberArray<Rest>]\n// \t: []\n// type ToNumber<S, L extends number[] = []> = `${L['length']}` extends S ? L['length'] : ToNumber<S, [...L, 0]>\n", "import { parseRawText } from '../../parser/src/basic.mjs';\nimport { translate } from './core.mjs';\nexport const getPartsFromString = (cache, text) => cache[text] || (cache[text] = parseRawText(text));\nconst translateString = (cache, pluralRules, formatters, text, ...args) => translate(getPartsFromString(cache, text), pluralRules, formatters, args);\nexport const i18nString = (locale, formatters = {}) => translateString.bind(null, {}, new Intl.PluralRules(locale), formatters);\nexport const typesafeI18nString = (locale, formatters = {}) => translateString.bind(null, {}, new Intl.PluralRules(locale), formatters);\n", "import { translate } from './core.mjs';\nimport { getPartsFromString } from './util.string.mjs';\nconst getTranslateInstance = (locale, formatters) => {\n    const cache = {};\n    const pluralRules = new Intl.PluralRules(locale);\n    return (text, ...args) => translate(getPartsFromString(cache, text), pluralRules, formatters, args);\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nexport function i18nObject(locale, translations, formatters = {}) {\n    return createProxy(translations, getTranslateInstance(locale, formatters));\n}\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nexport function typesafeI18nObject(locale, translations, formatters = {}) {\n    return createProxy(translations, getTranslateInstance(locale, formatters));\n}\nconst wrap = (proxyObject = {}, translateFn) => (typeof proxyObject === 'string'\n    ? translateFn.bind(null, proxyObject)\n    : Object.assign(Object.defineProperty(() => '', 'name', { writable: true }), proxyObject));\n/* PROXY-START */\nconst createProxy = (proxyObject, translateFn) => new Proxy(wrap(proxyObject, translateFn), {\n    get: (target, key) => {\n        if (key === Symbol.iterator)\n            return [][Symbol.iterator].bind(Object.values(target).map((entry) => wrap(entry, translateFn)));\n        return createProxy(target[key], translateFn);\n    },\n});\n/* PROXY-END */\n\n", "import { i18nObject } from './util.object.mjs';\nexport const i18n = (translations, formatters) => {\n    const cache = {};\n    return new Proxy({}, {\n        get: (_target, locale) => cache[locale] || (cache[locale] = i18nObject(locale, translations[locale], formatters[locale])),\n    });\n};\n"],
  "mappings": "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",
  "names": ["entry", "_a"]
}
