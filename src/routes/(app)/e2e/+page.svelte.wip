<script lang="ts">
  import {
    compileLayout,
    type VisualLayout,
  } from "$lib/serialization/visual-layout";
  import ccxLayout from "$lib/assets/layouts/generic/103-key.yml";
  import keycodes from "./keycodes.json";

  let width = $state(16);
  let height = $state(16);

  let layout = $state(compileLayout(ccxLayout as VisualLayout));
  let layoutMargin = $state(0.2);

  let timelineCanvas = $state<HTMLCanvasElement | undefined>(undefined);

  interface Report {
    modifiers?: number;
    keys?: number[];
  }

  interface Tick {
    ms?: number;
    reports?: Report[];
    keys?: number[];
  }

  let test: Tick[] = $state([
    { ms: 1, reports: [{ keys: [4] }], keys: [4] },
    { ms: 2, reports: [{ keys: [4, 2] }], keys: [4, 12] },
  ]);

  function timelineData<T extends { ms: number }>(
    ticks: T[],
    value: (tick: T) => number[],
  ) {
    let totalTicks = 0;
    const result = new Map<number, [number, number][]>();
    for (const tick of ticks) {
      const key = value(tick);
    }
  }

  let timelineData = $derived.by(() => {
    const result = new Map<number, [number, number][]>();
    for (const tick of test) {
      if (!tick.keys) continue;
      if (Array.isArray(action)) {
        if (typeof action[0] === "number") {
          ticks.push([action[0]]);
          totalTicks++;
        } else if (action.length === 0) {
          ticks.push([1]);
          totalTicks++;
        }
      }
      if (typeof action !== "number") continue;
      if (action >= 0) {
        if (!result.has(action)) {
          result.set(action, []);
        }
        result.get(action)!.push([totalTicks, test.length - 1]);
      } else {
        const value = result.get(~action)?.at(-1);
        if (!value || value[1] !== test.length - 1) continue;
        value[1] = totalTicks;
      }
    }
    return {
      totalTicks,
      ticks,
      presses: [...result.entries()].sort(([a], [b]) => a - b),
    };
  });
</script>

<h1>E2E Testing</h1>

{#snippet Layout(keys: Set<number>)}
  <svg viewBox="0 0 {layout.size[0]} {layout.size[1]}">
    {#each layout.keys as key}
      {#if key.shape === "square"}
        <rect
          x={key.pos[0] + layoutMargin / 2}
          y={key.pos[1] + layoutMargin / 2}
          rx={0.5 - layoutMargin / 2}
          width={key.size[0] - layoutMargin}
          height={key.size[1] - layoutMargin}
          fill={keys.has(key.id)
            ? "var(--md-sys-color-primary)"
            : "var(--md-sys-color-on-surface)"}
          opacity={keys.has(key.id) ? 1 : 0.1}
        />
      {/if}
    {/each}
  </svg>
{/snippet}

<canvas bind:this={timelineCanvas}></canvas>

<div class="t">
  {#each test as { ms, reports, keys }}
    <div class="tick">
      {ms}ms
      <div class="keys">
        {#each keys ?? [] as key}
          <kbd>{keycodes[key] ?? key}</kbd>
        {/each}
        <button class="icon">+</button>
      </div>
      {@render Layout(new Set(keys))}
      {#each reports ?? [] as report}
        <div class="report">
          <div class="modifiers">{report.modifiers}</div>
          <div class="keys">
            {#each report.keys ?? [] as key}
              <kbd>{keycodes[key] ?? key}</kbd>
            {/each}
          </div>
        </div>
      {/each}
    </div>
  {/each}
</div>

<div class="actions">
  {#each test as action, i}
    {@const isActionTick = Array.isArray(action)}
    {@const isActionPress = typeof action === "number" && action >= 0}
    {@const isActionRelease = typeof action === "number" && action < 0}
    {#if isActionTick}
      <div class="tick">
        <span class="icon">step_over</span>
        {action[0]}ms
      </div>
      {#if action[1]}
        <div class="report">
          {#each Array.from({ length: 8 }) as _, j}
            <div class="modifier">{j}</div>
          {/each}
          {#each action[1][1] as key}
            <div class="key">
              {key}
            </div>
          {/each}
        </div>
      {/if}
    {:else if typeof action === "string"}
      <div>Command: {action}</div>
    {:else if isActionPress}
      <button class="release" onclick={() => (test[i] = ~action)}
        >{action}</button
      >
    {:else if isActionRelease}
      <button class="press" onclick={() => (test[i] = ~action)}
        >{~action}</button
      >
    {:else}
      <div>Unsupported {action}</div>
    {/if}
  {/each}
</div>

<style lang="scss">
  svg {
    width: 100px;
  }

  $shadow-inset: 1px;

  .timeline {
    display: grid;
    grid-template-rows: auto repeat(auto-fit, minmax(var(--height), 1fr));
  }

  .timeline-press {
    margin-inline: calc(var(--width) / 2);
    border-radius: calc(var(--height) / 2);
    background-color: var(--md-sys-color-surface-variant);
    height: var(--height);
  }

  .actions {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .tick {
    display: flex;
    position: relative;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    cursor: ew-resize;
    padding: 0.5rem;
    user-select: none;

    span.icon {
      position: absolute;
      top: 0;
      transform: translateY(-50%);
    }
  }

  button {
    cursor: pointer;
    margin: 0;
    border: none;
    padding: 8px;
    aspect-ratio: 1;
    user-select: none;

    &.release {
      box-shadow:
        inset #{$shadow-inset} #{$shadow-inset} #{$shadow-inset * 2}
          rgba(0, 0, 0, 0.6),
        inset -#{$shadow-inset} -#{$shadow-inset} #{$shadow-inset * 2}
          rgba(255, 255, 255, 0.2);
      border-radius: 0.5rem;
    }

    &.press {
      box-shadow:
        #{$shadow-inset} #{$shadow-inset} #{$shadow-inset * 2}
          rgba(0, 0, 0, 0.6),
        -#{$shadow-inset} -#{$shadow-inset} #{$shadow-inset * 2}
          rgba(255, 255, 255, 0.2);
      border-radius: 0.5rem;
    }
  }
</style>
