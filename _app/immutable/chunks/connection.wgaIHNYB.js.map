{"version":3,"mappings":"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","names":["compressActions","actions","buffer","i","action","decompressActions","raw","LineBreakTransformer","chunk","controller","lines","line","SemVer","versionString","result","major","minor","patch","preRelease","meta","parsePhrase","phrase","_","stringifyPhrase","it","parseChordActions","deserializeActions","stringifyChordActions","serializeActions","native","PORT_FILTERS","KEY_COUNTS","define_import_meta_env_default","__vitePreload","getViablePorts","ports","usbProductId","usbVendorId","filter","canAutoConnect","timeout","promise","ms","timer","reject","CharaDevice","baudRate","manual","info","serialLog","version","company","device","chipset","e","decoderStream","value","command","writer","callback","send","read","resolveLock","resolve","expectedLength","commandString","readResult","array","count","index","chord","status","layer","id","position","type","bytes","persistentWritable","key","condition","persistedValue","store","writable","theme","userPreferences","preference","node","unsubscribe","update","serialPort","deviceChords","get","deviceLayout","deviceSettings","syncStatus","syncProgress","initSerial","sync","chordCount","max","settingInfo","current","progressTick","parsedSettings","parsedLayout","chordInfo"],"ignoreList":[],"sources":["../../../../../../src/lib/serialization/actions.ts","../../../../../../src/lib/serial/line-break-transformer.ts","../../../../../../src/lib/serial/sem-ver.ts","../../../../../../src/lib/serial/chord.ts","../../../../../../src/lib/serial/device.ts","../../../../../../src/lib/storage.ts","../../../../../../src/lib/preferences.ts","../../../../../../src/lib/serial/connection.ts"],"sourcesContent":["/**\n * Compresses an action list into a Uint8Array of variable-length 8/13-bit integers.\n *\n * Action codes <32 are invalid.\n */\nexport function compressActions(actions: number[]): Uint8Array {\n  const buffer = new Uint8Array(actions.length * 2);\n  let i = 0;\n  for (const action of actions) {\n    if (action > 0xff) {\n      buffer[i++] = action >>> 8;\n    }\n    buffer[i++] = action & 0xff;\n  }\n  return buffer.slice(0, i);\n}\n\n/**\n * Decompresses actions\n *\n * @see {compressActions}\n */\nexport function decompressActions(raw: Uint8Array): number[] {\n  const actions: number[] = [];\n  for (let i = 0; i < raw.length; i++) {\n    let action = raw[i]!;\n    if (action > 0 && action < 32 && i + 1 < raw.length) {\n      action = (action << 8) | raw[++i]!;\n    }\n    actions.push(action);\n  }\n  return actions;\n}\n","export class LineBreakTransformer {\n  private chunks = \"\";\n\n  // noinspection JSUnusedGlobalSymbols\n  transform(chunk: string, controller: TransformStreamDefaultController) {\n    this.chunks += chunk;\n    const lines = this.chunks.split(\"\\r\\n\");\n    this.chunks = lines.pop()!;\n    for (const line of lines) {\n      controller.enqueue(line);\n    }\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  flush(controller: TransformStreamDefaultController) {\n    controller.enqueue(this.chunks);\n  }\n}\n","export class SemVer {\n  major = 0;\n  minor = 0;\n  patch = 0;\n  preRelease?: string;\n  meta?: string;\n\n  constructor(versionString: string) {\n    const result =\n      /^([0-9]+)\\.([0-9]+)\\.([0-9]+)(?:-([0-9A-Za-z-]+(?:\\.[0-9A-Za-z-]+)*))?(?:\\+([0-9A-Za-z-]+))?$/.exec(\n        versionString,\n      );\n    if (!result) {\n      console.error(\"Invalid version string:\", versionString);\n    } else {\n      const [, major, minor, patch, preRelease, meta] = result;\n      this.major = Number.parseInt(major ?? \"NaN\");\n      this.minor = Number.parseInt(minor ?? \"NaN\");\n      this.patch = Number.parseInt(patch ?? \"NaN\");\n      if (preRelease) this.preRelease = preRelease;\n      if (meta) this.meta = meta;\n    }\n  }\n\n  toString() {\n    return (\n      `${this.major}.${this.minor}.${this.patch}` +\n      (this.preRelease ? `-${this.preRelease}` : \"\") +\n      (this.meta ? `+${this.meta}` : \"\")\n    );\n  }\n}\n","import { compressActions, decompressActions } from \"../serialization/actions\";\n\nexport interface Chord {\n  actions: number[];\n  phrase: number[];\n}\n\nexport function parsePhrase(phrase: string): number[] {\n  return decompressActions(\n    Uint8Array.from({ length: phrase.length / 2 }).map((_, i) =>\n      Number.parseInt(phrase.slice(i * 2, i * 2 + 2), 16),\n    ),\n  );\n}\n\nexport function stringifyPhrase(phrase: number[]): string {\n  return [...compressActions(phrase)]\n    .map((it) => it.toString(16).padStart(2, \"0\"))\n    .join(\"\")\n    .toUpperCase();\n}\n\nexport function parseChordActions(actions: string): number[] {\n  return deserializeActions(BigInt(`0x${actions}`));\n}\n\nexport function stringifyChordActions(actions: number[]): string {\n  return serializeActions(actions).toString(16).padStart(32, \"0\").toUpperCase();\n}\n\n/**\n * Binary serialization of actions\n *\n * Actions are represented as 10-bit codes, for a maximum of 12 actions\n */\nexport function serializeActions(actions: number[]): bigint {\n  let native = 0n;\n  for (let i = 1; i <= actions.length; i++) {\n    native |=\n      BigInt(actions[actions.length - i]! & 0x3ff) << BigInt((12 - i) * 10);\n  }\n  return native;\n}\n\n/**\n * @see {serializeActions}\n */\nexport function deserializeActions(native: bigint): number[] {\n  const actions = [];\n  for (let i = 0; i < 12; i++) {\n    const action = Number(native & 0x3ffn);\n    actions.push(action);\n    native >>= 10n;\n  }\n\n  return actions;\n}\n","import { LineBreakTransformer } from \"$lib/serial/line-break-transformer\";\nimport { serialLog } from \"$lib/serial/connection\";\nimport type { Chord } from \"$lib/serial/chord\";\nimport { SemVer } from \"$lib/serial/sem-ver\";\nimport {\n  parseChordActions,\n  parsePhrase,\n  stringifyChordActions,\n  stringifyPhrase,\n} from \"$lib/serial/chord\";\nimport { browser } from \"$app/environment\";\n\nconst PORT_FILTERS: Map<string, SerialPortFilter> = new Map([\n  [\"ONE M0\", { usbProductId: 32783, usbVendorId: 9114 }],\n  [\"TWO S3\", { usbProductId: 0x0056, usbVendorId: 0x2886 }],\n  [\"LITE S2\", { usbProductId: 33070, usbVendorId: 12346 }],\n  [\"LITE M0\", { usbProductId: 32796, usbVendorId: 9114 }],\n  [\"X\", { usbProductId: 33163, usbVendorId: 12346 }],\n]);\n\nconst KEY_COUNTS = {\n  ONE: 90,\n  TWO: 90,\n  LITE: 67,\n  X: 256,\n} as const;\n\nif (\n  browser &&\n  navigator.serial === undefined &&\n  import.meta.env.TAURI_FAMILY !== undefined\n) {\n  await import(\"./tauri-serial\");\n}\n\nexport async function getViablePorts(): Promise<SerialPort[]> {\n  return navigator.serial.getPorts().then((ports) =>\n    ports.filter((it) => {\n      const { usbProductId, usbVendorId } = it.getInfo();\n      for (const filter of PORT_FILTERS.values()) {\n        if (\n          filter.usbProductId === usbProductId &&\n          filter.usbVendorId === usbVendorId\n        ) {\n          return true;\n        }\n      }\n      return false;\n    }),\n  );\n}\n\ntype LengthArray<T, N extends number, R extends T[] = []> = number extends N\n  ? T[]\n  : R[\"length\"] extends N\n    ? R\n    : LengthArray<T, N, [T, ...R]>;\n\nexport async function canAutoConnect() {\n  return getViablePorts().then((it) => it.length === 1);\n}\n\nasync function timeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  let timer: number;\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) => {\n      timer = setTimeout(\n        () => reject(new Error(\"Timeout\")),\n        ms,\n      ) as unknown as number;\n    }),\n  ]).finally(() => clearTimeout(timer));\n}\n\nexport class CharaDevice {\n  private port!: SerialPort;\n  private reader!: ReadableStreamDefaultReader<string>;\n\n  private readonly abortController1 = new AbortController();\n  private readonly abortController2 = new AbortController();\n\n  private streamClosed!: Promise<void>;\n\n  private lock?: Promise<true>;\n\n  private readonly suspendDebounce = 100;\n  private suspendDebounceId?: number;\n\n  version!: SemVer;\n  company!: \"CHARACHORDER\";\n  device!: \"ONE\" | \"TWO\" | \"LITE\" | \"X\";\n  chipset!: \"M0\" | \"S2\" | \"S3\";\n  keyCount!: 90 | 67 | 256;\n\n  get portInfo() {\n    return this.port.getInfo();\n  }\n\n  constructor(private readonly baudRate = 115200) {}\n\n  async init(manual = false) {\n    try {\n      const ports = await getViablePorts();\n      this.port =\n        !manual && ports.length === 1\n          ? ports[0]!\n          : await navigator.serial.requestPort({\n              filters: [...PORT_FILTERS.values()],\n            });\n\n      await this.port.open({ baudRate: this.baudRate });\n      const info = this.port.getInfo();\n      serialLog.update((it) => {\n        it.push({\n          type: \"system\",\n          value: `Connected; ID: 0x${info.usbProductId?.toString(\n            16,\n          )}; Vendor: 0x${info.usbVendorId?.toString(16)}`,\n        });\n        return it;\n      });\n      await this.port.close();\n\n      this.version = new SemVer(\n        await this.send(1, \"VERSION\").then(([version]) => version),\n      );\n      const [company, device, chipset] = await this.send(3, \"ID\");\n      this.company = company as \"CHARACHORDER\";\n      this.device = device as \"ONE\" | \"TWO\" | \"LITE\" | \"X\";\n      this.chipset = chipset as \"M0\" | \"S2\" | \"S3\";\n      this.keyCount = KEY_COUNTS[this.device];\n    } catch (e) {\n      alert(e);\n      console.error(e);\n      throw e;\n    }\n  }\n\n  private async suspend() {\n    await this.reader.cancel();\n    await this.streamClosed.catch(() => {\n      /** noop */\n    });\n    this.reader.releaseLock();\n    await this.port.close();\n    serialLog.update((it) => {\n      it.push({\n        type: \"system\",\n        value: \"Connection suspended\",\n      });\n      return it;\n    });\n  }\n\n  private async wake() {\n    await this.port.open({ baudRate: this.baudRate });\n    const decoderStream = new TextDecoderStream();\n    this.streamClosed = this.port.readable!.pipeTo(decoderStream.writable, {\n      signal: this.abortController1.signal,\n    });\n\n    this.reader = decoderStream\n      .readable!.pipeThrough(new TransformStream(new LineBreakTransformer()), {\n        signal: this.abortController2.signal,\n      })\n      .getReader();\n    serialLog.update((it) => {\n      it.push({\n        type: \"system\",\n        value: \"Connection resumed\",\n      });\n      return it;\n    });\n  }\n\n  private async internalRead() {\n    try {\n      const { value } = await timeout(this.reader.read(), 5000);\n      serialLog.update((it) => {\n        it.push({\n          type: \"output\",\n          value: value!,\n        });\n        return it;\n      });\n      return value!;\n    } catch (e) {\n      serialLog.update((it) => {\n        it.push({\n          type: \"output\",\n          value: `${e}`,\n        });\n        return it;\n      });\n    }\n    return undefined;\n  }\n\n  /**\n   * Send a command to the device\n   */\n  private async internalSend(...command: string[]) {\n    const writer = this.port.writable!.getWriter();\n    try {\n      serialLog.update((it) => {\n        it.push({\n          type: \"input\",\n          value: command.join(\" \"),\n        });\n        return it;\n      });\n      await writer.write(new TextEncoder().encode(`${command.join(\" \")}\\r\\n`));\n    } finally {\n      writer.releaseLock();\n    }\n  }\n\n  async forget() {\n    await this.port.forget();\n  }\n\n  /**\n   * Read/write to serial port\n   */\n  async runWith<T>(\n    callback: (\n      send: typeof this.internalSend,\n      read: typeof this.internalRead,\n    ) => T | Promise<T>,\n  ): Promise<T> {\n    while (this.lock) {\n      await this.lock;\n    }\n    const send = this.internalSend.bind(this);\n    const read = this.internalRead.bind(this);\n    let resolveLock: (result: true) => void;\n    this.lock = new Promise<true>((resolve) => {\n      resolveLock = resolve;\n    });\n    let result!: T;\n    try {\n      if (this.suspendDebounceId) {\n        clearTimeout(this.suspendDebounceId);\n      } else {\n        await this.wake();\n      }\n      result = await callback(send, read);\n    } finally {\n      delete this.lock;\n      this.suspendDebounceId = setTimeout(() => {\n        // cannot be locked here as all the code until clearTimeout is sync\n        console.assert(this.lock === undefined);\n        this.lock = this.suspend().then(() => {\n          delete this.lock;\n          delete this.suspendDebounceId;\n          return true;\n        });\n      }, this.suspendDebounce) as any;\n      resolveLock!(true);\n      return result;\n    }\n  }\n\n  /**\n   * Send to serial port\n   */\n  async send<T extends number>(\n    expectedLength: T,\n    ...command: string[]\n  ): Promise<LengthArray<string, T>> {\n    return this.runWith(async (send, read) => {\n      await send(...command);\n      const commandString = command\n        .join(\" \")\n        .replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n      const readResult = await read();\n      if (readResult === undefined) {\n        console.error(\"No response\");\n        return Array(expectedLength).fill(\"NO_RESPONSE\") as LengthArray<\n          string,\n          T\n        >;\n      }\n      const array = readResult\n        .replace(new RegExp(`^${commandString} `), \"\")\n        .split(\" \");\n      if (array.length < expectedLength) {\n        console.error(\"Response too short\");\n        return array.concat(\n          Array(expectedLength - array.length).fill(\"TOO_SHORT\"),\n        ) as LengthArray<string, T>;\n      }\n      return array as LengthArray<string, T>;\n    });\n  }\n\n  async getChordCount(): Promise<number> {\n    const [count] = await this.send(1, \"CML C0\");\n    return Number.parseInt(count);\n  }\n\n  /**\n   * Retrieves a chord by index\n   */\n  async getChord(index: number | number[]): Promise<Chord> {\n    const [actions, phrase] = await this.send(2, `CML C1 ${index}`);\n    return {\n      actions: parseChordActions(actions),\n      phrase: parsePhrase(phrase),\n    };\n  }\n\n  /**\n   * Retrieves the phrase for a set of actions\n   */\n  async getChordPhrase(actions: number[]): Promise<number[] | undefined> {\n    const [phrase] = await this.send(\n      1,\n      `CML C2 ${stringifyChordActions(actions)}`,\n    );\n    return phrase === \"2\" ? undefined : parsePhrase(phrase);\n  }\n\n  async setChord(chord: Chord) {\n    const [status] = await this.send(\n      1,\n      \"CML\",\n      \"C3\",\n      stringifyChordActions(chord.actions),\n      stringifyPhrase(chord.phrase),\n    );\n    if (status !== \"0\") console.error(`Failed with status ${status}`);\n  }\n\n  async deleteChord(chord: Pick<Chord, \"actions\">) {\n    const status = await this.send(\n      1,\n      `CML C4 ${stringifyChordActions(chord.actions)}`,\n    );\n    if (status?.at(-1) !== \"2\" && status?.at(-1) !== \"0\")\n      throw new Error(`Failed with status ${status}`);\n  }\n\n  /**\n   * Sets an action to the layout\n   * @param layer the layer (usually 1-3)\n   * @param id id of the key, refer to the individual device for where each key is\n   * @param action the assigned action id\n   */\n  async setLayoutKey(layer: number, id: number, action: number) {\n    const [status] = await this.send(1, `VAR B4 A${layer} ${id} ${action}`);\n    if (status !== \"0\") throw new Error(`Failed with status ${status}`);\n  }\n\n  /**\n   * Gets the assigned action from the layout\n   * @param layer the layer (usually 1-3)\n   * @param id id of the key, refer to the individual device for where each key is\n   * @returns the assigned action id\n   */\n  async getLayoutKey(layer: number, id: number) {\n    const [position, status] = await this.send(2, `VAR B3 A${layer} ${id}`);\n    if (status !== \"0\") throw new Error(`Failed with status ${status}`);\n    return Number(position);\n  }\n\n  /**\n   * Permanently stores settings and layout to the device.\n   *\n   * CAUTION: Device may degrade prematurely above 10,000-25,000 commits.\n   *\n   * **This does not need to be called for chords**\n   */\n  async commit() {\n    const [status] = await this.send(1, \"VAR B0\");\n    if (status !== \"0\") throw new Error(`Failed with status ${status}`);\n  }\n\n  /**\n   * Sets a setting on the device.\n   *\n   * Settings are applied until the next reboot or loss of power.\n   * To permanently store the settings, you *must* call commit.\n   */\n  async setSetting(id: number, value: number) {\n    const [status] = await this.send(\n      1,\n      `VAR B2 ${id.toString(16).toUpperCase()} ${value}`,\n    );\n    if (status !== \"0\") throw new Error(`Failed with status ${status}`);\n  }\n\n  /**\n   * Retrieves a setting from the device\n   */\n  async getSetting(id: number): Promise<number> {\n    const [value, status] = await this.send(\n      2,\n      `VAR B1 ${id.toString(16).toUpperCase()}`,\n    );\n    if (status !== \"0\")\n      throw new Error(\n        `Setting \"0x${id.toString(16)}\" doesn't exist (Status code ${status})`,\n      );\n    return Number(value);\n  }\n\n  /**\n   * Reboots the device\n   */\n  async reboot() {\n    await this.send(0, \"RST\");\n  }\n\n  /**\n   * Reboots the device to the bootloader\n   */\n  async bootloader() {\n    await this.send(0, \"RST BOOTLOADER\");\n  }\n\n  /**\n   * Resets the device\n   */\n  async reset(\n    type: \"FACTORY\" | \"PARAMS\" | \"KEYMAPS\" | \"STARTER\" | \"CLEARCML\" | \"FUNC\",\n  ) {\n    await this.send(0, `RST ${type}`);\n  }\n\n  /**\n   * Returns the current number of bytes available in SRAM.\n   *\n   * This is useful for debugging when there is a suspected heap or stack issue.\n   */\n  async getRamBytesAvailable(): Promise<number> {\n    return Number(await this.send(1, \"RAM\").then(([bytes]) => bytes));\n  }\n}\n","import type { Writable } from \"svelte/store\";\nimport { writable } from \"svelte/store\";\nimport { browser } from \"$app/environment\";\n\nexport function persistentWritable<T>(\n  key: string,\n  value: T,\n  condition?: () => boolean,\n): Writable<T> {\n  if (browser) {\n    const persistedValue = localStorage.getItem(key);\n    const store =\n      persistedValue !== null\n        ? writable(JSON.parse(persistedValue))\n        : writable(value);\n    store.subscribe((value) => {\n      if (!condition || condition())\n        localStorage.setItem(key, JSON.stringify(value));\n    });\n\n    return store;\n  } else {\n    return writable(value);\n  }\n}\n","import type { Action } from \"svelte/action\";\nimport { persistentWritable } from \"$lib/storage\";\n\nexport interface UserPreferences {\n  backup: boolean;\n  autoConnect: boolean;\n}\n\nexport const theme = persistentWritable(\"user-theme\", {\n  color: \"#6D81C7\",\n  mode: \"dark\" as \"light\" | \"dark\" | \"auto\",\n});\n\nexport const userPreferences = persistentWritable<UserPreferences>(\n  \"user-preferences\",\n  {\n    backup: false,\n    autoConnect: false,\n  },\n);\n\nexport const preference: Action<HTMLInputElement, keyof UserPreferences> = (\n  node,\n  key,\n) => {\n  const unsubscribe = userPreferences.subscribe((it) => {\n    node.checked = it[key];\n  });\n  function update() {\n    userPreferences.update((value) => {\n      value[key] = node.checked;\n      return value;\n    });\n  }\n  node.addEventListener(\"input\", update);\n\n  return {\n    destroy() {\n      unsubscribe();\n      node.removeEventListener(\"input\", update);\n    },\n  };\n};\n","import { get, writable } from \"svelte/store\";\nimport { CharaDevice } from \"$lib/serial/device\";\nimport type { Chord } from \"$lib/serial/chord\";\nimport type { Writable } from \"svelte/store\";\nimport type { CharaLayout } from \"$lib/serialization/layout\";\nimport { persistentWritable } from \"$lib/storage\";\nimport { userPreferences } from \"$lib/preferences\";\nimport settingInfo from \"$lib/assets/settings.yml\";\n\nexport const serialPort = writable<CharaDevice | undefined>();\n\nexport interface SerialLogEntry {\n  type: \"input\" | \"output\" | \"system\";\n  value: string;\n}\n\nexport const serialLog = writable<SerialLogEntry[]>([]);\n\n/**\n * Chords as read from the device\n */\nexport const deviceChords = persistentWritable<Chord[]>(\n  \"chord-library\",\n  [],\n  () => get(userPreferences).backup,\n);\n\n/**\n * Layout as read from the device\n */\nexport const deviceLayout = persistentWritable<CharaLayout>(\n  \"layout\",\n  [[], [], []],\n  () => get(userPreferences).backup,\n);\n\n/**\n * Settings as read from the device\n */\nexport const deviceSettings = persistentWritable<number[]>(\n  \"device-settings\",\n  [],\n  () => get(userPreferences).backup,\n);\n\nexport const syncStatus: Writable<\n  \"done\" | \"error\" | \"downloading\" | \"uploading\"\n> = writable(\"done\");\n\nexport interface ProgressInfo {\n  max: number;\n  current: number;\n}\nexport const syncProgress = writable<ProgressInfo | undefined>(undefined);\n\nexport async function initSerial(manual = false) {\n  const device = get(serialPort) ?? new CharaDevice();\n  await device.init(manual);\n  serialPort.set(device);\n  await sync();\n}\n\nexport async function sync() {\n  const device = get(serialPort);\n  if (!device) return;\n  const chordCount = await device.getChordCount();\n  syncStatus.set(\"downloading\");\n\n  const max =\n    Object.keys(settingInfo[\"settings\"]).length +\n    device.keyCount * 3 +\n    chordCount;\n  let current = 0;\n  syncProgress.set({ max, current });\n  function progressTick() {\n    current++;\n    syncProgress.set({ max, current });\n  }\n\n  const parsedSettings: number[] = [];\n  for (const key in settingInfo[\"settings\"]) {\n    try {\n      parsedSettings[Number.parseInt(key)] = await device.getSetting(\n        Number.parseInt(key),\n      );\n    } catch {}\n    progressTick();\n  }\n  deviceSettings.set(parsedSettings);\n\n  const parsedLayout: CharaLayout = [[], [], []];\n  for (let layer = 1; layer <= 3; layer++) {\n    for (let i = 0; i < device.keyCount; i++) {\n      parsedLayout[layer - 1]![i] = await device.getLayoutKey(layer, i);\n      progressTick();\n    }\n  }\n  deviceLayout.set(parsedLayout);\n\n  const chordInfo = [];\n  for (let i = 0; i < chordCount; i++) {\n    chordInfo.push(await device.getChord(i));\n    progressTick();\n  }\n  deviceChords.set(chordInfo);\n  syncStatus.set(\"done\");\n  syncProgress.set(undefined);\n}\n"],"file":"_app/immutable/chunks/connection.wgaIHNYB.js"}